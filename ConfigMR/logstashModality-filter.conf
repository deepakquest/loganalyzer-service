input { 
  
  
  file {
	path => "${SPRSNAP_LOC}/export/home/sdc/logfiles/mediacreator*.log"
	type => "media"
	start_position => "beginning"
	codec => multiline {
		pattern => "^%{LOGLEVEL}"
		negate => "true"
		what => "previous"
		}
	add_field => { "component" => "mediacreator"}
	sincedb_path => "NUL"
}
file {
    path => "${SPRSNAP_LOC}/export/home/sdc/logfiles/u2d.*.log"
	type => "u2d"
    start_position => "beginning"
	codec => multiline {
		pattern => "^%{LOGLEVEL}"
		negate => "true"
		what => "previous"
		}
	add_field => { "component" => "coreviewer"}
	sincedb_path => "NUL"
  }
  file {
	path => "${SPRSNAP_LOC}/export/home/sdc/nuevo/logfiles/nusm.log"
	type => "nuevosm"
	start_position => "beginning"
	codec => multiline {
		pattern => "^%{YEAR}-%{MONTHNUM}-%{MONTHDAY}"
		negate => "true"
		what => "previous"
		}
	add_field => { "component" => "nuevosm"}
	sincedb_path => "NUL"
}
file {
	path => "${SPRSNAP_LOC}/export/home/sdc/nuevo/logfiles/browser.log.*"
	type => "browser"
	codec => multiline {
		patterns_dir => ["D:/LA/ELK/logstash-7.0.0/bin/patterns"]
		pattern => "^%{BROWSERLOG}"
		what => "previous"
		negate => "true"
		}
	add_field => { "logname" => "browser.log"}
    add_field => { "component" => "nuevobrowser"}
	start_position => "beginning"
	sincedb_path => "NUL"
	}	

}

filter {

	if [type] == "u2d" {
		grok {
		  match => { "message" => "(?m)^%{LOGLEVEL:level}:%{GREEDYDATA:num}:(?<logdate>%{MONTHDAY} %{MONTH} %{YEAR} %{TIME}) :%{JAVACLASS};%{WORD};%{GREEDYDATA}: %{JAVACLASS:exception}: %{GREEDYDATA:excepStack}" }
		  
		  }
		  if "_grokparsefailure" in [tags]{
				grok {
					match => { "message" => "(?m)^%{LOGLEVEL:level}:%{GREEDYDATA:num}:(?<logdate>%{MONTHDAY} %{MONTH} %{YEAR} %{TIME}) :%{GREEDYDATA:fullmsg}" }
					remove_tag => ["_grokparsefailure"]
				}
		  }
		
		date {
			match => [ "logdate", "dd MMM yyyy HH:mm:ss:SSS" ]
			target => "@timestamp"
		}
	}else if [type] == "media" {
		grok {
		  match => { "message" => "%{LOGLEVEL:level}:%{GREEDYDATA:num}:(?<logdate>[0-9]{13});%{JAVACLASS};(%{WORD}|<%{WORD}>);%{GREEDYDATA}: %{JAVACLASS:exception}; %{GREEDYDATA:excepStack}" }
		}
		
		if "_grokparsefailure" in [tags]{
				grok {
						#INFO:-1:1550185391284;com.ge.med.mediacreator.ui.MediaCreator;main;Extended CUI Look and Feel is loaded by default
						 match => { "message" => "%{LOGLEVEL:level}:%{GREEDYDATA:num}:(?<logdate>[0-9]{13});%{GREEDYDATA:fullmsg}" }
							remove_tag => ["_grokparsefailure"]
						}
		}
		date {
			match => [ "logdate", "UNIX_MS" ]
			target => "@timestamp"
		}
	}
	else if [type] == "nuevosm" {
		grok {
		  match => { "message" => "(?<logdate>%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{TIME}),%{GREEDYDATA:num} %{LOGLEVEL:level} %{GREEDYDATA:fullmsg}" }
		}
		date {
			match => [ "logdate", "yyyy-MM-dd H:mm:ss" ]
			target => "@timestamp"
		}
	}
	else if [type] == "browser" {
	
		
		mutate {
                gsub => ['message', "\n", " "]
        }
		#Dec 28, 2018 12:32:15 PM com.ge.hc.nuevo.browser.preview.ImagePreviewPanel clear
		if "multiline" in [tags] and [component]=="nuevobrowser" {
                # Aply pattern to disect the message.
                grok  {
                        match => {
                                "message" =>"(?<logdate>%{MONTH} %{MONTHDAY}, %{YEAR} %{TIME}) %{GREEDYDATA:timeMeridian} %{JAVACLASS:classname} %{GREEDYDATA:function} %{LOGLEVEL:level}: %{GREEDYDATA} %{JAVACLASS:exception} %{GREEDYDATA:excepStack}"							
                        }
                }			
				
        }
		if "_grokparsefailure" in [tags]{
				grok {
						 match => {"message" =>"(?<logdate>%{MONTH} %{MONTHDAY}, %{YEAR} %{TIME}) %{GREEDYDATA:timeMeridian} %{JAVACLASS:classname} %{GREEDYDATA:function} %{LOGLEVEL:level}: %{GREEDYDATA:fullmsg}"
							remove_tag => ["_grokparsefailure"]
						}
					}
		}
       # mutate {
         #       copy => { message => "dest_field" }
       # }
		
		date {
		#fDec 28, 2018 12:32:07
			match => [ "logdate", "MMM dd, yyyy HH:mm:ss" ]
			target => "@timestamp"
		}

	}
}

output {
 elasticsearch { 
  hosts => ["localhost:9200"]
  index => "sample"
  }
  stdout { codec => rubydebug }
}